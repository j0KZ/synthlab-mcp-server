/**
 * C++ enum parser for VCV Rack module source files.
 *
 * Extracts ParamIds, InputIds, OutputIds, LightIds enums and
 * configParam/configInput/configOutput/configSwitch/configButton labels.
 *
 * Used by build-vcv-registry.ts to generate TypeScript registry files.
 */

export interface ParsedEnum {
  name: string;
  id: number;
  removed?: boolean;
}

export interface ParsedLabel {
  enumName: string;
  label: string;
  min?: number;
  max?: number;
  default?: number;
}

export interface ParsedModule {
  params: ParsedEnum[];
  inputs: ParsedEnum[];
  outputs: ParsedEnum[];
  lights: ParsedEnum[];
  labels: Map<string, ParsedLabel>;
}

/**
 * Classify an enum type string from the regex match into a category.
 */
function classifyEnum(typeStr: string): "params" | "inputs" | "outputs" | "lights" | null {
  const lower = typeStr.toLowerCase();
  if (lower.startsWith("param")) return "params";
  if (lower.startsWith("input")) return "inputs";
  if (lower.startsWith("output")) return "outputs";
  if (lower.startsWith("light")) return "lights";
  return null;
}

/**
 * Split enum body by commas, respecting parentheses (for ENUMS(NAME, N) macro).
 */
function splitEnumMembers(body: string): string[] {
  const members: string[] = [];
  let current = "";
  let depth = 0;

  for (const ch of body) {
    if (ch === "(") depth++;
    if (ch === ")") depth--;
    if (ch === "," && depth === 0) {
      members.push(current.trim());
      current = "";
    } else {
      current += ch;
    }
  }
  if (current.trim()) members.push(current.trim());
  return members.filter(Boolean);
}

/**
 * Parse enum members from the body of an enum declaration.
 *
 * Handles:
 *   - Simple members: FREQ_PARAM,
 *   - Members with explicit values: FREQ_PARAM = 0,
 *   - ENUMS macro: ENUMS(CH_INPUTS, 4) → occupies 4 sequential IDs
 *   - Sentinels: NUM_PARAMS, PARAMS_LEN, *_LAST (skipped)
 *   - Removed: MODE_PARAM, // removed
 */
function parseEnumBody(body: string): ParsedEnum[] {
  const result: ParsedEnum[] = [];
  let currentId = 0;

  // Step 1: Detect which names are marked "removed" (before stripping comments)
  const removedNames = new Set<string>();
  for (const line of body.split("\n")) {
    if (/\/\/.*removed/i.test(line)) {
      const nameMatch = line.match(/^\s*(\w+)/);
      if (nameMatch) removedNames.add(nameMatch[1]);
    }
  }

  // Step 2: Strip preprocessor blocks (#ifdef...#endif) and standalone directives.
  // Regex matches only innermost blocks (no nested #if inside), loop peels from inside out.
  let prev;
  do {
    prev = body;
    body = body.replace(/#if(?:def|ndef)?\b[^\n]*(?:(?!#if(?:def|ndef)?\b)[\s\S])*?#endif[^\n]*/g, "");
  } while (body !== prev);
  body = body.replace(/^[\t ]*#\w+[^\n]*/gm, "");

  // Step 3: Strip line comments, collapse whitespace
  const cleaned = body
    .replace(/\/\/[^\n]*/g, "")
    .replace(/\s+/g, " ")
    .trim();

  // Step 4: Split by comma respecting parentheses
  const parts = splitEnumMembers(cleaned);

  for (const part of parts) {
    if (!part) continue;

    // Check for ENUMS(NAME, COUNT) macro
    const enumsMacro = part.match(/^ENUMS\s*\(\s*(\w+)\s*,\s*(\d+)\s*\)/);
    if (enumsMacro) {
      const name = enumsMacro[1];
      const count = parseInt(enumsMacro[2], 10);
      const removed = removedNames.has(name);
      result.push({ name, id: currentId, ...(removed ? { removed: true } : {}) });
      currentId += count;
      continue;
    }

    // Skip _LAST sentinels (generated by ENUMS macro expansion)
    if (/_LAST\s*=/.test(part)) continue;

    // Handle explicit value assignment: NAME = VALUE
    const assignMatch = part.match(/^(\w+)\s*=\s*(.+)$/);
    if (assignMatch) {
      const name = assignMatch[1];
      const valueExpr = assignMatch[2].trim();

      // Skip sentinels
      if (/^(NUM_|PARAMS_LEN|INPUTS_LEN|OUTPUTS_LEN|LIGHTS_LEN)/.test(name)) continue;

      const numVal = parseInt(valueExpr, 10);
      if (!isNaN(numVal)) {
        currentId = numVal;
      } else {
        // Try resolving MEMBER + N or MEMBER - N expressions
        const exprMatch = valueExpr.match(/^(\w+)\s*([+-])\s*(\d+)$/);
        if (exprMatch) {
          const ref = result.find(r => r.name === exprMatch[1]);
          const offset = parseInt(exprMatch[3], 10);
          if (ref && !isNaN(offset)) {
            currentId = exprMatch[2] === "+" ? ref.id + offset : ref.id - offset;
          } else {
            // Unresolvable expression — skip this member entirely
            continue;
          }
        } else {
          // Not a numeric value and not a MEMBER +/- N pattern — skip
          continue;
        }
      }
      const removed = removedNames.has(name);
      result.push({ name, id: currentId, ...(removed ? { removed: true } : {}) });
      currentId++;
      continue;
    }

    // Simple member: NAME
    const simpleName = part.replace(/[^a-zA-Z0-9_]/g, "");
    if (!simpleName) continue;

    // Skip sentinels
    if (/^(NUM_|PARAMS_LEN$|INPUTS_LEN$|OUTPUTS_LEN$|LIGHTS_LEN$)/.test(simpleName)) continue;

    const removed = removedNames.has(simpleName);
    result.push({ name: simpleName, id: currentId, ...(removed ? { removed: true } : {}) });
    currentId++;
  }

  return result;
}

/**
 * Extract configParam/configInput/configOutput/configSwitch/configButton labels.
 *
 * Patterns:
 *   configParam(FREQ_PARAM, -76.f, 76.f, 0.f, "Frequency", " Hz")
 *   configSwitch(MODE_PARAM, 0.f, 2.f, 0.f, "Mode", {"A", "B", "C"})
 *   configButton(TRIG_PARAM, "Trigger")
 *   configInput(PITCH_INPUT, "1V/oct pitch")
 *   configOutput(SIN_OUTPUT, "Sine")
 */
function extractLabels(source: string): Map<string, ParsedLabel> {
  const labels = new Map<string, ParsedLabel>();

  // configParam(ENUM, min, max, default, "label" ...)
  const paramRe = /config(?:Param|Switch)\s*\(\s*(\w+)\s*,\s*([^,]*),\s*([^,]*),\s*([^,]*),\s*"([^"]*)"/g;
  let m: RegExpExecArray | null;
  while ((m = paramRe.exec(source)) !== null) {
    const enumName = m[1];
    const label = m[5];
    const min = parseFloat(m[2]);
    const max = parseFloat(m[3]);
    const def = parseFloat(m[4]);
    labels.set(enumName, {
      enumName,
      label,
      ...(isFinite(min) ? { min } : {}),
      ...(isFinite(max) ? { max } : {}),
      ...(isFinite(def) ? { default: def } : {}),
    });
  }

  // configButton(ENUM, "label")
  const buttonRe = /configButton\s*\(\s*(\w+)\s*,\s*"([^"]*)"/g;
  while ((m = buttonRe.exec(source)) !== null) {
    labels.set(m[1], { enumName: m[1], label: m[2] });
  }

  // configInput(ENUM, "label")
  const inputRe = /configInput\s*\(\s*(\w+)\s*,\s*"([^"]*)"/g;
  while ((m = inputRe.exec(source)) !== null) {
    labels.set(m[1], { enumName: m[1], label: m[2] });
  }

  // configOutput(ENUM, "label")
  const outputRe = /configOutput\s*\(\s*(\w+)\s*,\s*"([^"]*)"/g;
  while ((m = outputRe.exec(source)) !== null) {
    labels.set(m[1], { enumName: m[1], label: m[2] });
  }

  return labels;
}

/**
 * Generate a human-readable label from an enum member name.
 * Fallback when configParam/configInput/configOutput doesn't provide one.
 *
 * FREQ_PARAM → "Freq"
 * PITCH_INPUT → "Pitch"
 * SIN_OUTPUT → "Sin"
 */
export function enumNameToLabel(name: string): string {
  // Strip known suffixes
  const stripped = name
    .replace(/_PARAM$/, "")
    .replace(/_INPUT$/, "")
    .replace(/_OUTPUT$/, "")
    .replace(/_LIGHT$/, "");

  // Convert UPPER_SNAKE to Title Case
  return stripped
    .split("_")
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
    .join(" ");
}

/**
 * Parse a VCV Rack C++ source file for enum definitions and config labels.
 */
export function parseCppSource(source: string): ParsedModule {
  const result: ParsedModule = {
    params: [],
    inputs: [],
    outputs: [],
    lights: [],
    labels: extractLabels(source),
  };

  // Match enum declarations: enum ParamIds { ... }
  // Supports: ParamIds, ParamId, ParamsIds, InputIds, OutputIds, LightIds, etc.
  const enumRe = /enum\s+(Param|Input|Output|Light)s?(Id|Ids)\s*\{([\s\S]+?)\}/g;
  let m: RegExpExecArray | null;

  while ((m = enumRe.exec(source)) !== null) {
    const typeStr = m[1];
    const category = classifyEnum(typeStr);
    if (!category) continue;

    const body = m[3];
    const members = parseEnumBody(body);
    result[category] = members;
  }

  return result;
}
